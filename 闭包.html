<!-- https://segmentfault.com/a/1190000004676467 -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>闭包</title>
</head>
<body>

</body>
<script type="text/javascript">
	/******************这个例子其实是作用域的问题************************************/
	for (var i = 0; i < 3; i++) {
		setTimeout(function(){
			alert(i);   
		},i*1000);
	}
	/*上述代码每隔一秒弹出 i=3
	* 原因： js中不存在块作用域，也就是说for循环中的i和函数中的i是同一个，所以当for循环执行结束
	*        后i的值变为3，函数体中弹出的值也是3
			 我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个i的副本。但是根据作用域的工作原理，实际情况是尽管循环中的三个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。那么要怎样做才能达到我们想象中的样子呢？答案是我们需要在每一次迭代的过程中都创建一个闭包作用域。
	* 解决方法：1.使用let
	*		    2.IIFE立即执行一个函数来创建作用域*/	
	
	/* 方法一let： 弹出 0，1, 2
		下面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
	*/
	for (let i = 0; i < 3; i++) {
		setTimeout(function(){
			alert(i);   
		},i*1000);
	}
	// 方法二IFE：
	for(var i=1; i<6; i++){
        (function(){
            setTImeout(function time(){
                console.log(i)
            }, i*1000)//不行，封闭的作用域为空
        })();
    }
	/*每一次迭代我们都创建了一个封闭的作用域(每次迭代都有自己的作用域)。但是这样做仍旧不行，为什么呢？因为虽然每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来，但我们封闭的作用域是空的，所以必须传点东西过去才能实现我们想要的结果。*/
	 for(var i=1; i<6; i++){
        (function(){
            var j = i;
            setTImeout(function time(){
                console.log(j);
            }, j*1000);
        })();//ok
    }

	/*改进一下
		在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数可以将新的作用域封闭在每个迭代内部，我们同时在迭代的过程中将每次迭代的i值作为参数传入进新的作用域，这样在迭代中创建的封闭作用域就都会含有一个具有正确值的变量供我们访问。
		
		在循环中使用IFE会为每个循环都生成一个新的作用域，在每轮循环中都将for循环中的i作为参数传入新的作用域，这样通过IFE创建的封闭作用域就会在每轮循环中都有一个不同的值。
		
		严格来说并不是闭包：
			IIFE即立即执行函数表达式，第一个（）让函数变为函数表达式，第二个（）函数执行。为什么说他严格上来讲并不是闭包呢？因为在示例代码中函数并不是在它本身的词法作用域之外执行的，它在其定义时所在的作用域执行，a是通过词法作用域查找到的，并不是闭包发现的。尽管IIFE本身并不是观察闭包的恰当例子，但他的确创建了一个封闭的作用域，并且也是最常用来创建被封闭起来的闭包的工具。
	*/
	for (var i = 0; i < 3; i++) {
		(function(j){
			setTimeout(function(){
				alert(j);   
			},j*1000)
		})(i);
	}
	/*****************闭包******************************************/
	/*闭包的形成：
		某函数（outer）执行完毕后，内部返回一个函数（inner），通常整个内部作用域都会被销毁，因为有垃圾回收机制来释放不再使用的内存空间。但是闭包可以阻止这件事发生，事实上内部作用域依然存在没有被回收。这是因为inner依旧持有对outer作用域的引用，而这个引用就叫做闭包。

		无论通过什么手段将内部函数传递到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
	*/
	//Example1
	function outer(){
        var a = 2;
        function inner(){
            console.log(a);
        }
        return inner;
    }
    var innerFunc = outer();
    innerFunc(); //这就是闭包的效果

	//Example2
    function foo(){
        var a = 2;
        function inner(){
            console.log(a)//2
        }
        outer(inner);
    }
    function outer(fn){
        fn(); //这就是闭包
    }

    /*Example3解释：
    	将名为time的内部函数传递给setTimeout(),time具有涵盖wait()作用域的闭包，因此也保有对变量message的引用。wait执行1s后（函数执行结束内部作用域理应消失），其内部作用域并不会消失，time()函数依旧保有对wait()作用域的闭包，在引擎内部，内置的工具函数setTimeout()会持有一个对参数的引用，也就是time。引擎会调用time这个函数，而词法作用域在这个过程中保持完整。
    	这就是闭包

	闭包有哪些应用呢？
		其实包括定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers或者任何其他的异步(或者同步)任务中，只要使用回掉函数，实际上就是在使用闭包!!!
    */
    function wait(message){
        setTimeout(function time(){
            console.log(message);
        }, 1000);
    }
    wait("hello clousre");
</script>	
</html>